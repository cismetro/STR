<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apostila: Servi√ßos em Tempo Real - Python, SocketIO & WebSocket</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        dark: {
                            bg: '#181818',
                            card: '#2a2a2a',
                            text: '#ffffff'
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-white dark:bg-dark-bg text-gray-900 dark:text-dark-text transition-colors duration-300">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-primary text-white py-6 shadow-lg">
            <div class="container mx-auto px-4">
                <h1 class="text-3xl font-bold text-center">
                    <i class="fas fa-broadcast-tower mr-3"></i>
                    Apostila: Servi√ßos em Tempo Real
                </h1>
                <p class="text-center mt-2 text-blue-100">Python ‚Ä¢ SocketIO ‚Ä¢ WebSocket ‚Ä¢ Tempo Real</p>
            </div>
        </header>

        <!-- Navigation -->
        <nav class="bg-gray-100 dark:bg-dark-card border-b border-gray-200 dark:border-gray-700 sticky top-0 z-50">
            <div class="container mx-auto px-4">
                <div class="flex flex-wrap gap-2 py-3 overflow-x-auto">
                    <button onclick="showSection('intro')" class="nav-btn px-4 py-2 rounded-lg bg-primary text-white">
                        <i class="fas fa-home mr-2"></i>Introdu√ß√£o
                    </button>
                    <button onclick="showSection('websocket-basics')" class="nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">
                        <i class="fas fa-network-wired mr-2"></i>WebSocket B√°sico
                    </button>
                    <button onclick="showSection('socketio')" class="nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">
                        <i class="fas fa-plug mr-2"></i>Socket.IO
                    </button>
                    <button onclick="showSection('chat-demo')" class="nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">
                        <i class="fas fa-comments mr-2"></i>Chat Demo
                    </button>
                    <button onclick="showSection('real-time-apps')" class="nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">
                        <i class="fas fa-chart-line mr-2"></i>Apps Tempo Real
                    </button>
                    <button onclick="showSection('production')" class="nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600">
                        <i class="fas fa-server mr-2"></i>Produ√ß√£o
                    </button>
                </div>
            </div>
        </nav>

        <!-- Main Content -->
        <main class="container mx-auto px-4 py-8">
            <!-- Introdu√ß√£o -->
            <section id="intro" class="section">
                <div class="bg-gradient-to-r from-primary to-purple-600 text-white rounded-lg p-8 mb-8">
                    <h2 class="text-3xl font-bold mb-4">
                        <i class="fas fa-rocket mr-3"></i>Bem-vindo √† Apostila Completa!
                    </h2>
                    <p class="text-lg mb-4">Esta √© sua jornada completa atrav√©s do mundo dos servi√ßos em tempo real com Python.</p>
                    <div class="grid md:grid-cols-3 gap-4 mt-6">
                        <div class="bg-white bg-opacity-20 rounded-lg p-4">
                            <i class="fas fa-globe text-2xl mb-2"></i>
                            <h3 class="font-bold">WebSocket Nativo</h3>
                            <p class="text-sm">Protocolo fundamental para comunica√ß√£o bidirecional</p>
                        </div>
                        <div class="bg-white bg-opacity-20 rounded-lg p-4">
                            <i class="fas fa-plug text-2xl mb-2"></i>
                            <h3 class="font-bold">Socket.IO</h3>
                            <p class="text-sm">Framework poderoso com fallbacks e recursos avan√ßados</p>
                        </div>
                        <div class="bg-white bg-opacity-20 rounded-lg p-4">
                            <i class="fas fa-cogs text-2xl mb-2"></i>
                            <h3 class="font-bold">Aplica√ß√µes Pr√°ticas</h3>
                            <p class="text-sm">Exemplos reais e casos de uso em produ√ß√£o</p>
                        </div>
                    </div>
                </div>

                <div class="grid md:grid-cols-2 gap-8 mb-8">
                    <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                        <h3 class="text-xl font-bold mb-4 text-primary">
                            <i class="fas fa-question-circle mr-2"></i>O que s√£o Servi√ßos em Tempo Real?
                        </h3>
                        <ul class="space-y-2 text-gray-700 dark:text-gray-300">
                            <li><i class="fas fa-check text-green-500 mr-2"></i>Comunica√ß√£o instant√¢nea entre cliente e servidor</li>
                            <li><i class="fas fa-check text-green-500 mr-2"></i>Dados sincronizados em tempo real</li>
                            <li><i class="fas fa-check text-green-500 mr-2"></i>Experi√™ncia de usu√°rio interativa</li>
                            <li><i class="fas fa-check text-green-500 mr-2"></i>Notifica√ß√µes push instant√¢neas</li>
                        </ul>
                    </div>

                    <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                        <h3 class="text-xl font-bold mb-4 text-primary">
                            <i class="fas fa-tools mr-2"></i>Tecnologias que Vamos Usar
                        </h3>
                        <div class="space-y-3">
                            <div class="flex items-center">
                                <div class="w-12 h-8 bg-blue-500 rounded mr-3 flex items-center justify-center">
                                    <i class="fab fa-python text-white"></i>
                                </div>
                                <div>
                                    <div class="font-semibold">Python</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Linguagem principal</div>
                                </div>
                            </div>
                            <div class="flex items-center">
                                <div class="w-12 h-8 bg-green-500 rounded mr-3 flex items-center justify-center">
                                    <i class="fas fa-plug text-white"></i>
                                </div>
                                <div>
                                    <div class="font-semibold">Socket.IO</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Framework completo</div>
                                </div>
                            </div>
                            <div class="flex items-center">
                                <div class="w-12 h-8 bg-purple-500 rounded mr-3 flex items-center justify-center">
                                    <i class="fas fa-network-wired text-white"></i>
                                </div>
                                <div>
                                    <div class="font-semibold">WebSocket</div>
                                    <div class="text-sm text-gray-600 dark:text-gray-400">Protocolo nativo</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-yellow-50 dark:bg-yellow-900 border-l-4 border-yellow-400 p-6 rounded-lg">
                    <h3 class="text-lg font-semibold text-yellow-800 dark:text-yellow-200 mb-2">
                        <i class="fas fa-lightbulb mr-2"></i>Casos de Uso Populares
                    </h3>
                    <div class="grid md:grid-cols-2 gap-4 text-yellow-700 dark:text-yellow-300">
                        <div>
                            <i class="fas fa-comments mr-2"></i>Sistemas de Chat<br>
                            <i class="fas fa-gamepad mr-2"></i>Jogos Multiplayer<br>
                            <i class="fas fa-chart-line mr-2"></i>Dashboards em Tempo Real<br>
                            <i class="fas fa-bell mr-2"></i>Notifica√ß√µes Push
                        </div>
                        <div>
                            <i class="fas fa-users mr-2"></i>Colabora√ß√£o Online<br>
                            <i class="fas fa-money-bill-wave mr-2"></i>Trading de Criptomoedas<br>
                            <i class="fas fa-map-marked-alt mr-2"></i>Rastreamento de Localiza√ß√£o<br>
                            <i class="fas fa-video mr-2"></i>Streaming de V√≠deo
                        </div>
                    </div>
                </div>
            </section>

            <!-- WebSocket B√°sico -->
            <section id="websocket-basics" class="section hidden">
                <h2 class="text-3xl font-bold mb-6 text-primary">
                    <i class="fas fa-network-wired mr-3"></i>WebSocket B√°sico
                </h2>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">1. Servidor WebSocket Simples</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># servidor_websocket.py
import asyncio
import websockets
import json
from datetime import datetime

# Lista de clientes conectados
connected_clients = set()

async def register_client(websocket):
    """Registra um novo cliente"""
    connected_clients.add(websocket)
    print(f"Cliente conectado. Total: {len(connected_clients)}")

async def unregister_client(websocket):
    """Remove um cliente"""
    connected_clients.remove(websocket)
    print(f"Cliente desconectado. Total: {len(connected_clients)}")

async def broadcast_message(message, sender=None):
    """Envia mensagem para todos os clientes conectados"""
    if connected_clients:
        # Remove o remetente da lista se especificado
        recipients = connected_clients.copy()
        if sender in recipients:
            recipients.remove(sender)
        
        # Envia para todos os destinat√°rios
        await asyncio.gather(
            *[client.send(message) for client in recipients],
            return_exceptions=True
        )

async def handle_client(websocket, path):
    """Manipula conex√µes de clientes"""
    await register_client(websocket)
    
    try:
        async for message in websocket:
            try:
                # Parse da mensagem JSON
                data = json.loads(message)
                
                # Adiciona timestamp
                data['timestamp'] = datetime.now().isoformat()
                
                # Log no servidor
                print(f"Mensagem recebida: {data}")
                
                # Retransmite para outros clientes
                response = json.dumps(data)
                await broadcast_message(response, sender=websocket)
                
            except json.JSONDecodeError:
                # Mensagem inv√°lida
                error_response = json.dumps({
                    'type': 'error',
                    'message': 'Formato de mensagem inv√°lido'
                })
                await websocket.send(error_response)
                
    except websockets.exceptions.ConnectionClosed:
        pass
    finally:
        await unregister_client(websocket)

# Configura√ß√£o do servidor
async def start_server():
    """Inicia o servidor WebSocket"""
    print("Iniciando servidor WebSocket na porta 8765...")
    
    # Servidor b√°sico
    server = await websockets.serve(
        handle_client, 
        "localhost", 
        8765,
        # Configura√ß√µes opcionais
        ping_interval=20,  # Ping a cada 20s
        ping_timeout=10,   # Timeout de 10s
        max_size=1024*1024 # Max 1MB por mensagem
    )
    
    print("Servidor rodando! Acesse ws://localhost:8765")
    return server

if __name__ == "__main__":
    # Executa o servidor
    asyncio.run(start_server())
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">2. Cliente WebSocket Python</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># cliente_websocket.py
import asyncio
import websockets
import json
import threading
from datetime import datetime

class WebSocketClient:
    def __init__(self, uri):
        self.uri = uri
        self.websocket = None
        self.connected = False
        
    async def connect(self):
        """Conecta ao servidor"""
        try:
            self.websocket = await websockets.connect(self.uri)
            self.connected = True
            print(f"Conectado ao servidor: {self.uri}")
            
            # Inicia o loop de recebimento
            await self.listen_for_messages()
            
        except Exception as e:
            print(f"Erro na conex√£o: {e}")
            self.connected = False
    
    async def listen_for_messages(self):
        """Escuta mensagens do servidor"""
        try:
            async for message in self.websocket:
                data = json.loads(message)
                await self.handle_message(data)
                
        except websockets.exceptions.ConnectionClosed:
            print("Conex√£o fechada pelo servidor")
            self.connected = False
        except Exception as e:
            print(f"Erro ao receber mensagem: {e}")
    
    async def handle_message(self, data):
        """Processa mensagens recebidas"""
        msg_type = data.get('type', 'unknown')
        timestamp = data.get('timestamp', '')
        
        if msg_type == 'chat':
            user = data.get('user', 'An√¥nimo')
            message = data.get('message', '')
            print(f"[{timestamp}] {user}: {message}")
            
        elif msg_type == 'notification':
            message = data.get('message', '')
            print(f"üîî Notifica√ß√£o: {message}")
            
        elif msg_type == 'error':
            message = data.get('message', '')
            print(f"‚ùå Erro: {message}")
            
        else:
            print(f"Mensagem recebida: {data}")
    
    async def send_message(self, message_type, content):
        """Envia mensagem para o servidor"""
        if not self.connected or not self.websocket:
            print("N√£o conectado ao servidor")
            return
            
        try:
            message = {
                'type': message_type,
                'timestamp': datetime.now().isoformat(),
                **content
            }
            
            await self.websocket.send(json.dumps(message))
            
        except Exception as e:
            print(f"Erro ao enviar mensagem: {e}")
    
    async def send_chat_message(self, user, message):
        """Envia mensagem de chat"""
        await self.send_message('chat', {
            'user': user,
            'message': message
        })
    
    async def close(self):
        """Fecha a conex√£o"""
        if self.websocket:
            await self.websocket.close()
            self.connected = False
            print("Conex√£o fechada")

# Exemplo de uso interativo
async def interactive_client():
    """Cliente interativo via terminal"""
    client = WebSocketClient("ws://localhost:8765")
    
    # Conecta ao servidor em uma task separada
    connect_task = asyncio.create_task(client.connect())
    
    # Aguarda um pouco para estabelecer conex√£o
    await asyncio.sleep(1)
    
    if not client.connected:
        print("Falha na conex√£o!")
        return
    
    # Input do usu√°rio
    user_name = input("Digite seu nome: ")
    print("Digite suas mensagens (ou 'quit' para sair):")
    
    def get_input():
        """Thread para capturar input do usu√°rio"""
        while client.connected:
            try:
                message = input()
                if message.lower() == 'quit':
                    break
                
                # Envia mensagem (precisa ser executado no loop principal)
                asyncio.run_coroutine_threadsafe(
                    client.send_chat_message(user_name, message),
                    asyncio.get_event_loop()
                )
            except EOFError:
                break
    
    # Inicia thread de input
    input_thread = threading.Thread(target=get_input)
    input_thread.daemon = True
    input_thread.start()
    
    # Aguarda a conex√£o terminar
    try:
        await connect_task
    except KeyboardInterrupt:
        pass
    finally:
        await client.close()

if __name__ == "__main__":
    asyncio.run(interactive_client())
</code></pre>
                </div>

                <div class="bg-blue-50 dark:bg-blue-900 border-l-4 border-blue-400 p-6 rounded-lg mb-8">
                    <h3 class="text-lg font-semibold text-blue-800 dark:text-blue-200 mb-2">
                        <i class="fas fa-info-circle mr-2"></i>Como Executar
                    </h3>
                    <div class="text-blue-700 dark:text-blue-300">
                        <ol class="list-decimal list-inside space-y-2">
                            <li>Instale o websockets: <code class="bg-blue-200 dark:bg-blue-800 px-2 py-1 rounded">pip install websockets</code></li>
                            <li>Execute o servidor: <code class="bg-blue-200 dark:bg-blue-800 px-2 py-1 rounded">python servidor_websocket.py</code></li>
                            <li>Em outro terminal, execute o cliente: <code class="bg-blue-200 dark:bg-blue-800 px-2 py-1 rounded">python cliente_websocket.py</code></li>
                            <li>Abra v√°rios clientes para testar o chat!</li>
                        </ol>
                    </div>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                    <h3 class="text-xl font-bold mb-4">3. Cliente JavaScript (Frontend)</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-javascript">// websocket_client.js
class WebSocketClient {
    constructor(url) {
        this.url = url;
        this.ws = null;
        this.connected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
    }

    connect() {
        try {
            this.ws = new WebSocket(this.url);
            
            this.ws.onopen = (event) => {
                console.log('Conectado ao WebSocket');
                this.connected = true;
                this.reconnectAttempts = 0;
                this.onConnected(event);
            };
            
            this.ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    this.onMessage(data);
                } catch (e) {
                    console.error('Erro ao parsear mensagem:', e);
                }
            };
            
            this.ws.onclose = (event) => {
                console.log('Conex√£o fechada');
                this.connected = false;
                this.onDisconnected(event);
                
                // Tentativa de reconex√£o autom√°tica
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    setTimeout(() => {
                        this.reconnectAttempts++;
                        console.log(`Tentativa de reconex√£o ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
                        this.connect();
                    }, this.reconnectDelay * this.reconnectAttempts);
                }
            };
            
            this.ws.onerror = (error) => {
                console.error('Erro no WebSocket:', error);
                this.onError(error);
            };
            
        } catch (error) {
            console.error('Erro ao conectar:', error);
        }
    }

    send(type, data) {
        if (this.connected && this.ws.readyState === WebSocket.OPEN) {
            const message = {
                type: type,
                timestamp: new Date().toISOString(),
                ...data
            };
            this.ws.send(JSON.stringify(message));
        } else {
            console.warn('WebSocket n√£o est√° conectado');
        }
    }

    sendChatMessage(user, message) {
        this.send('chat', { user, message });
    }

    close() {
        if (this.ws) {
            this.ws.close();
        }
    }

    // M√©todos a serem sobrescritos
    onConnected(event) { }
    onDisconnected(event) { }
    onMessage(data) { }
    onError(error) { }
}

// Exemplo de uso
const client = new WebSocketClient('ws://localhost:8765');

client.onConnected = () => {
    document.getElementById('status').textContent = 'Conectado ‚úÖ';
};

client.onDisconnected = () => {
    document.getElementById('status').textContent = 'Desconectado ‚ùå';
};

client.onMessage = (data) => {
    if (data.type === 'chat') {
        addMessageToChat(data.user, data.message, data.timestamp);
    }
};

function addMessageToChat(user, message, timestamp) {
    const chatContainer = document.getElementById('chat-messages');
    const messageElement = document.createElement('div');
    messageElement.className = 'message';
    
    const time = new Date(timestamp).toLocaleTimeString();
    messageElement.innerHTML = `
        <span class="timestamp">[${time}]</span>
        <span class="user">${user}:</span>
        <span class="message">${message}</span>
    `;
    
    chatContainer.appendChild(messageElement);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

// Conecta automaticamente
client.connect();
</code></pre>
                </div>
            </section>

            <!-- Socket.IO -->
            <section id="socketio" class="section hidden">
                <h2 class="text-3xl font-bold mb-6 text-primary">
                    <i class="fas fa-plug mr-3"></i>Socket.IO - Framework Completo
                </h2>

                <div class="bg-gradient-to-r from-green-500 to-blue-500 text-white rounded-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-2">
                        <i class="fas fa-star mr-2"></i>Por que Socket.IO?
                    </h3>
                    <div class="grid md:grid-cols-2 gap-4">
                        <div>
                            <i class="fas fa-check mr-2"></i>Fallback autom√°tico para polling<br>
                            <i class="fas fa-check mr-2"></i>Reconex√£o autom√°tica<br>
                            <i class="fas fa-check mr-2"></i>Salas e namespaces<br>
                            <i class="fas fa-check mr-2"></i>Broadcast seletivo
                        </div>
                        <div>
                            <i class="fas fa-check mr-2"></i>Middleware avan√ßado<br>
                            <i class="fas fa-check mr-2"></i>Autentica√ß√£o integrada<br>
                            <i class="fas fa-check mr-2"></i>Multiplexing<br>
                            <i class="fas fa-check mr-2"></i>Compatibilidade ampla
                        </div>
                    </div>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">1. Servidor Socket.IO Completo</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># servidor_socketio.py
import socketio
import asyncio
import uvicorn
from datetime import datetime
import json
import logging

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Cria servidor Socket.IO com configura√ß√µes avan√ßadas
sio = socketio.AsyncServer(
    cors_allowed_origins="*",  # Em produ√ß√£o, especifique dom√≠nios
    logger=True,
    engineio_logger=True,
    async_mode='asgi'
)

# Dicion√°rio para armazenar dados dos usu√°rios
connected_users = {}
chat_rooms = {}

class ChatRoom:
    def __init__(self, name):
        self.name = name
        self.users = set()
        self.messages = []
        self.created_at = datetime.now()
    
    def add_user(self, user_id, username):
        self.users.add(user_id)
        logger.info(f"Usu√°rio {username} entrou na sala {self.name}")
    
    def remove_user(self, user_id):
        self.users.discard(user_id)
        if user_id in connected_users:
            username = connected_users[user_id]['username']
            logger.info(f"Usu√°rio {username} saiu da sala {self.name}")
    
    def add_message(self, user_id, message):
        username = connected_users.get(user_id, {}).get('username', 'An√¥nimo')
        msg_data = {
            'id': len(self.messages),
            'user_id': user_id,
            'username': username,
            'message': message,
            'timestamp': datetime.now().isoformat()
        }
        self.messages.append(msg_data)
        return msg_data

# Middleware para autentica√ß√£o
@sio.event
async def connect(sid, environ, auth):
    """Evento de conex√£o"""
    try:
        # Extrai dados de autentica√ß√£o
        username = auth.get('username', f'User_{sid[:8]}') if auth else f'User_{sid[:8]}'
        user_id = auth.get('user_id', sid) if auth else sid
        
        # Armazena dados do usu√°rio
        connected_users[sid] = {
            'user_id': user_id,
            'username': username,
            'connected_at': datetime.now(),
            'rooms': set()
        }
        
        logger.info(f"Usu√°rio conectado: {username} (SID: {sid})")
        
        # Envia dados de conex√£o para o cliente
        await sio.emit('connected', {
            'user_id': user_id,
            'username': username,
            'timestamp': datetime.now().isoformat()
        }, room=sid)
        
        # Atualiza lista de usu√°rios online
        await broadcast_user_list()
        
    except Exception as e:
        logger.error(f"Erro na conex√£o: {e}")
        return False  # Rejeita a conex√£o

@sio.event
async def disconnect(sid):
    """Evento de desconex√£o"""
    if sid in connected_users:
        user_data = connected_users[sid]
        username = user_data['username']
        
        # Remove usu√°rio de todas as salas
        for room_name in user_data['rooms'].copy():
            await leave_room_handler(sid, room_name)
        
        # Remove usu√°rio da lista
        del connected_users[sid]
        
        logger.info(f"Usu√°rio desconectado: {username} (SID: {sid})")
        
        # Atualiza lista de usu√°rios
        await broadcast_user_list()

@sio.event
async def join_room(sid, data):
    """Usu√°rio entra em uma sala"""
    try:
        room_name = data.get('room', 'general')
        
        if sid not in connected_users:
            return {'error': 'Usu√°rio n√£o autenticado'}
        
        user_data = connected_users[sid]
        username = user_data['username']
        
        # Cria sala se n√£o existir
        if room_name not in chat_rooms:
            chat_rooms[room_name] = ChatRoom(room_name)
        
        # Adiciona usu√°rio √† sala
        await sio.enter_room(sid, room_name)
        chat_rooms[room_name].add_user(sid, username)
        user_data['rooms'].add(room_name)
        
        # Notifica outros usu√°rios da sala
        await sio.emit('user_joined', {
            'username': username,
            'room': room_name,
            'timestamp': datetime.now().isoformat()
        }, room=room_name, skip_sid=sid)
        
        # Envia hist√≥rico de mensagens para o usu√°rio
        recent_messages = chat_rooms[room_name].messages[-50:]  # √öltimas 50
        await sio.emit('room_history', {
            'room': room_name,
            'messages': recent_messages
        }, room=sid)
        
        # Confirma entrada na sala
        await sio.emit('joined_room', {
            'room': room_name,
            'users_count': len(chat_rooms[room_name].users)
        }, room=sid)
        
        return {'success': True, 'room': room_name}
        
    except Exception as e:
        logger.error(f"Erro ao entrar na sala: {e}")
        return {'error': str(e)}

@sio.event
async def leave_room_handler(sid, room_name):
    """Usu√°rio sai de uma sala"""
    try:
        if sid in connected_users and room_name in chat_rooms:
            user_data = connected_users[sid]
            username = user_data['username']
            
            # Remove da sala
            await sio.leave_room(sid, room_name)
            chat_rooms[room_name].remove_user(sid)
            user_data['rooms'].discard(room_name)
            
            # Notifica outros usu√°rios
            await sio.emit('user_left', {
                'username': username,
                'room': room_name,
                'timestamp': datetime.now().isoformat()
            }, room=room_name)
            
    except Exception as e:
        logger.error(f"Erro ao sair da sala: {e}")

@sio.event
async def send_message(sid, data):
    """Envia mensagem para uma sala"""
    try:
        if sid not in connected_users:
            return {'error': 'Usu√°rio n√£o autenticado'}
        
        room_name = data.get('room', 'general')
        message = data.get('message', '').strip()
        
        if not message:
            return {'error': 'Mensagem vazia'}
        
        if room_name not in chat_rooms:
            return {'error': 'Sala n√£o encontrada'}
        
        # Adiciona mensagem √† sala
        msg_data = chat_rooms[room_name].add_message(sid, message)
        
        # Envia para todos na sala
        await sio.emit('new_message', msg_data, room=room_name)
        
        return {'success': True, 'message_id': msg_data['id']}
        
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem: {e}")
        return {'error': str(e)}

@sio.event
async def private_message(sid, data):
    """Envia mensagem privada"""
    try:
        if sid not in connected_users:
            return {'error': 'Usu√°rio n√£o autenticado'}
        
        target_user = data.get('target_user')
        message = data.get('message', '').strip()
        
        if not message:
            return {'error': 'Mensagem vazia'}
        
        sender = connected_users[sid]
        
        # Encontra SID do usu√°rio alvo
        target_sid = None
        for user_sid, user_data in connected_users.items():
            if user_data['username'] == target_user:
                target_sid = user_sid
                break
        
        if not target_sid:
            return {'error': 'Usu√°rio n√£o encontrado'}
        
        msg_data = {
            'from': sender['username'],
            'to': target_user,
            'message': message,
            'timestamp': datetime.now().isoformat(),
            'type': 'private'
        }
        
        # Envia para ambos os usu√°rios
        await sio.emit('private_message', msg_data, room=target_sid)
        await sio.emit('private_message', msg_data, room=sid)
        
        return {'success': True}
        
    except Exception as e:
        logger.error(f"Erro ao enviar mensagem privada: {e}")
        return {'error': str(e)}

@sio.event
async def get_rooms(sid):
    """Retorna lista de salas dispon√≠veis"""
    try:
        rooms_info = []
        for room_name, room in chat_rooms.items():
            rooms_info.append({
                'name': room_name,
                'users_count': len(room.users),
                'created_at': room.created_at.isoformat()
            })
        
        return {'rooms': rooms_info}
        
    except Exception as e:
        logger.error(f"Erro ao buscar salas: {e}")
        return {'error': str(e)}

async def broadcast_user_list():
    """Envia lista de usu√°rios online para todos"""
    try:
        users_online = []
        for sid, user_data in connected_users.items():
            users_online.append({
                'username': user_data['username'],
                'rooms': list(user_data['rooms'])
            })
        
        await sio.emit('users_online', {'users': users_online})
        
    except Exception as e:
        logger.error(f"Erro ao broadcast da lista de usu√°rios: {e}")

# Cria aplica√ß√£o ASGI
app = socketio.ASGIApp(sio)

if __name__ == "__main__":
    # Configura√ß√£o do servidor
    config = uvicorn.Config(
        app=app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
        reload=True  # Remove em produ√ß√£o
    )
    
    server = uvicorn.Server(config)
    print("Servidor Socket.IO iniciando na porta 8000...")
    print("Acesse: http://localhost:8000")
    
    # Inicia o servidor
    asyncio.run(server.serve())
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">2. Cliente Python Socket.IO</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># cliente_socketio.py
import socketio
import asyncio
import threading
import json
from datetime import datetime

class SocketIOClient:
    def __init__(self, server_url, username):
        self.server_url = server_url
        self.username = username
        self.sio = socketio.AsyncClient()
        self.connected = False
        self.current_room = None
        
        # Registra eventos
        self.setup_events()
    
    def setup_events(self):
        """Configura eventos do Socket.IO"""
        
        @self.sio.event
        async def connect():
            print(f"‚úÖ Conectado como {self.username}")
            self.connected = True
        
        @self.sio.event
        async def disconnect():
            print("‚ùå Desconectado do servidor")
            self.connected = False
        
        @self.sio.event
        async def connected(data):
            print(f"Dados de conex√£o: {data}")
        
        @self.sio.event
        async def new_message(data):
            timestamp = datetime.fromisoformat(data['timestamp'].replace('Z', '+00:00'))
            time_str = timestamp.strftime('%H:%M:%S')
            print(f"[{time_str}] {data['username']}: {data['message']}")
        
        @self.sio.event
        async def private_message(data):
            timestamp = datetime.fromisoformat(data['timestamp'].replace('Z', '+00:00'))
            time_str = timestamp.strftime('%H:%M:%S')
            print(f"üîí [{time_str}] Privado de {data['from']}: {data['message']}")
        
        @self.sio.event
        async def user_joined(data):
            print(f"üëã {data['username']} entrou na sala {data['room']}")
        
        @self.sio.event
        async def user_left(data):
            print(f"üëã {data['username']} saiu da sala {data['room']}")
        
        @self.sio.event
        async def joined_room(data):
            self.current_room = data['room']
            print(f"üè† Voc√™ entrou na sala '{data['room']}' ({data['users_count']} usu√°rios)")
        
        @self.sio.event
        async def room_history(data):
            print(f"\nüìú Hist√≥rico da sala '{data['room']}':")
            for msg in data['messages'][-10:]:  # √öltimas 10 mensagens
                timestamp = datetime.fromisoformat(msg['timestamp'])
                time_str = timestamp.strftime('%H:%M:%S')
                print(f"  [{time_str}] {msg['username']}: {msg['message']}")
            print("---")
        
        @self.sio.event
        async def users_online(data):
            if data['users']:
                print(f"\nüë• Usu√°rios online ({len(data['users'])}):")
                for user in data['users']:
                    rooms = ', '.join(user['rooms']) if user['rooms'] else 'nenhuma sala'
                    print(f"  ‚Ä¢ {user['username']} ({rooms})")
    
    async def connect_to_server(self):
        """Conecta ao servidor"""
        try:
            auth_data = {
                'username': self.username,
                'user_id': f"user_{self.username}"
            }
            
            await self.sio.connect(
                self.server_url,
                auth=auth_data,
                wait_timeout=10
            )
            
        except Exception as e:
            print(f"Erro na conex√£o: {e}")
            return False
        
        return True
    
    async def join_room(self, room_name):
        """Entra em uma sala"""
        if not self.connected:
            print("N√£o conectado ao servidor")
            return
        
        result = await self.sio.call('join_room', {'room': room_name})
        if result.get('error'):
            print(f"Erro ao entrar na sala: {result['error']}")
    
    async def send_message(self, message):
        """Envia mensagem para a sala atual"""
        if not self.current_room:
            print("Voc√™ n√£o est√° em nenhuma sala")
            return
        
        result = await self.sio.call('send_message', {
            'room': self.current_room,
            'message': message
        })
        
        if result.get('error'):
            print(f"Erro ao enviar mensagem: {result['error']}")
    
    async def send_private_message(self, target_user, message):
        """Envia mensagem privada"""
        result = await self.sio.call('private_message', {
            'target_user': target_user,
            'message': message
        })
        
        if result.get('error'):
            print(f"Erro ao enviar mensagem privada: {result['error']}")
    
    async def get_rooms(self):
        """Lista salas dispon√≠veis"""
        result = await self.sio.call('get_rooms')
        if result.get('rooms'):
            print("\nüè† Salas dispon√≠veis:")
            for room in result['rooms']:
                print(f"  ‚Ä¢ {room['name']} ({room['users_count']} usu√°rios)")
        else:
            print("Nenhuma sala dispon√≠vel")
    
    async def disconnect(self):
        """Desconecta do servidor"""
        if self.connected:
            await self.sio.disconnect()

# Interface interativa
async def interactive_client():
    """Cliente interativo via terminal"""
    
    # Configura√ß√£o inicial
    print("=== Cliente Socket.IO ===")
    username = input("Digite seu nome de usu√°rio: ")
    server_url = input("URL do servidor (padr√£o: http://localhost:8000): ") or "http://localhost:8000"
    
    client = SocketIOClient(server_url, username)
    
    # Conecta ao servidor
    print("Conectando...")
    if not await client.connect_to_server():
        print("Falha na conex√£o!")
        return
    
    # Aguarda estabelecer conex√£o
    await asyncio.sleep(1)
    
    print(f"""
‚úÖ Conectado com sucesso!

Comandos dispon√≠veis:
  /join <sala>           - Entrar em uma sala
  /rooms                 - Listar salas
  /private <user> <msg>  - Mensagem privada
  /help                  - Mostrar ajuda
  /quit                  - Sair

Para enviar mensagem na sala: digite diretamente
""")
    
    # Loop principal
    try:
        while client.connected:
            message = await asyncio.get_event_loop().run_in_executor(
                None, input, f"[{client.current_room or 'sem sala'}] > "
            )
            
            if message.startswith('/'):
                # Processa comandos
                parts = message.split(' ', 2)
                command = parts[0]
                
                if command == '/quit':
                    break
                elif command == '/join' and len(parts) > 1:
                    await client.join_room(parts[1])
                elif command == '/rooms':
                    await client.get_rooms()
                elif command == '/private' and len(parts) > 2:
                    await client.send_private_message(parts[1], parts[2])
                elif command == '/help':
                    print("Comandos: /join, /rooms, /private, /help, /quit")
                else:
                    print("Comando inv√°lido. Use /help para ver comandos")
            
            elif message.strip():
                # Envia mensagem normal
                await client.send_message(message)
    
    except KeyboardInterrupt:
        pass
    finally:
        await client.disconnect()
        print("Desconectado!")

if __name__ == "__main__":
    # Instala depend√™ncias necess√°rias
    # pip install python-socketio[asyncio_client] uvicorn
    
    asyncio.run(interactive_client())
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                    <h3 class="text-xl font-bold mb-4">3. Cliente JavaScript/HTML Completo</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-html"><!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Socket.IO</title>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .chat-container { border: 1px solid #ddd; height: 400px; overflow-y: auto; padding: 10px; margin-bottom: 10px; }
        .message { margin-bottom: 8px; }
        .timestamp { color: #888; font-size: 0.8em; }
        .username { font-weight: bold; color: #007bff; }
        .private { background: #fff3cd; padding: 5px; border-radius: 3px; }
        .system { color: #6c757d; font-style: italic; }
        .input-group { display: flex; gap: 10px; margin-bottom: 10px; }
        input[type="text"] { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
        button { padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
        .users-list { background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 10px; }
        .room-info { background: #e3f2fd; padding: 10px; border-radius: 4px; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí¨ Chat Socket.IO</h1>
        
        <!-- Status da conex√£o -->
        <div id="connection-status" class="room-info">
            Desconectado
        </div>
        
        <!-- Informa√ß√µes da sala atual -->
        <div id="room-info" class="room-info" style="display: none;">
            Sala: <span id="current-room">-</span> | Usu√°rios online: <span id="users-count">0</span>
        </div>
        
        <!-- Controles -->
        <div class="input-group">
            <input type="text" id="username-input" placeholder="Seu nome de usu√°rio" value="Usuario123">
            <button onclick="connectToServer()">Conectar</button>
            <button onclick="disconnectFromServer()">Desconectar</button>
        </div>
        
        <div class="input-group">
            <input type="text" id="room-input" placeholder="Nome da sala" value="geral">
            <button onclick="joinRoom()">Entrar na Sala</button>
            <button onclick="listRooms()">Listar Salas</button>
        </div>
        
        <!-- Lista de usu√°rios online -->
        <div id="users-online" class="users-list" style="display: none;">
            <strong>Usu√°rios Online:</strong>
            <div id="users-list"></div>
        </div>
        
        <!-- √Årea do chat -->
        <div id="chat-messages" class="chat-container"></div>
        
        <!-- Input de mensagem -->
        <div class="input-group">
            <input type="text" id="message-input" placeholder="Digite sua mensagem..." disabled>
            <button onclick="sendMessage()" disabled id="send-btn">Enviar</button>
        </div>
        
        <!-- Mensagem privada -->
        <div class="input-group">
            <input type="text" id="private-user" placeholder="Usu√°rio para mensagem privada">
            <input type="text" id="private-message" placeholder="Mensagem privada">
            <button onclick="sendPrivateMessage()">Enviar Privado</button>
        </div>
    </div>

    <script>
        class ChatClient {
            constructor() {
                this.socket = null;
                this.connected = false;
                this.username = null;
                this.currentRoom = null;
                
                // Elementos DOM
                this.connectionStatus = document.getElementById('connection-status');
                this.chatMessages = document.getElementById('chat-messages');
                this.messageInput = document.getElementById('message-input');
                this.sendBtn = document.getElementById('send-btn');
                this.roomInfo = document.getElementById('room-info');
                this.usersOnline = document.getElementById('users-online');
                
                // Event listeners
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
            }
            
            connect(username) {
                if (this.connected) {
                    this.addSystemMessage('J√° conectado ao servidor');
                    return;
                }
                
                this.username = username;
                
                // Configura√ß√£o da conex√£o
                this.socket = io('http://localhost:8000', {
                    auth: {
                        username: username,
                        user_id: `user_${username}_${Date.now()}`
                    },
                    transports: ['websocket', 'polling']
                });
                
                this.setupEventHandlers();
                
                this.addSystemMessage(`Conectando como ${username}...`);
            }
            
            setupEventHandlers() {
                // Eventos de conex√£o
                this.socket.on('connect', () => {
                    this.connected = true;
                    this.connectionStatus.textContent = `‚úÖ Conectado como ${this.username}`;
                    this.connectionStatus.style.background = '#d4edda';
                    this.enableControls(true);
                    this.addSystemMessage('Conectado com sucesso!');
                });
                
                this.socket.on('disconnect', () => {
                    this.connected = false;
                    this.connectionStatus.textContent = '‚ùå Desconectado';
                    this.connectionStatus.style.background = '#f8d7da';
                    this.enableControls(false);
                    this.addSystemMessage('Desconectado do servidor');
                });
                
                this.socket.on('connect_error', (error) => {
                    this.addSystemMessage(`Erro de conex√£o: ${error.message}`);
                });
                
                // Eventos do chat
                this.socket.on('new_message', (data) => {
                    this.addChatMessage(data);
                });
                
                this.socket.on('private_message', (data) => {
                    this.addPrivateMessage(data);
                });
                
                this.socket.on('user_joined', (data) => {
                    this.addSystemMessage(`${data.username} entrou na sala`);
                });
                
                this.socket.on('user_left', (data) => {
                    this.addSystemMessage(`${data.username} saiu da sala`);
                });
                
                this.socket.on('joined_room', (data) => {
                    this.currentRoom = data.room;
                    document.getElementById('current-room').textContent = data.room;
                    document.getElementById('users-count').textContent = data.users_count;
                    this.roomInfo.style.display = 'block';
                    this.addSystemMessage(`Voc√™ entrou na sala "${data.room}"`);
                });
                
                this.socket.on('room_history', (data) => {
                    this.addSystemMessage(`=== Hist√≥rico da sala "${data.room}" ===`);
                    data.messages.slice(-10).forEach(msg => {
                        this.addChatMessage(msg);
                    });
                    this.addSystemMessage('=== Fim do hist√≥rico ===');
                });
                
                this.socket.on('users_online', (data) => {
                    this.updateUsersList(data.users);
                });
            }
            
            joinRoom(roomName) {
                if (!this.connected) {
                    this.addSystemMessage('N√£o conectado ao servidor');
                    return;
                }
                
                this.socket.emit('join_room', { room: roomName }, (response) => {
                    if (response.error) {
                        this.addSystemMessage(`Erro ao entrar na sala: ${response.error}`);
                    }
                });
            }
            
            sendMessage() {
                const message = this.messageInput.value.trim();
                if (!message || !this.connected || !this.currentRoom) return;
                
                this.socket.emit('send_message', {
                    room: this.currentRoom,
                    message: message
                }, (response) => {
                    if (response.error) {
                        this.addSystemMessage(`Erro ao enviar mensagem: ${response.error}`);
                    } else {
                        this.messageInput.value = '';
                    }
                });
            }
            
            sendPrivateMessage(targetUser, message) {
                if (!this.connected) return;
                
                this.socket.emit('private_message', {
                    target_user: targetUser,
                    message: message
                }, (response) => {
                    if (response.error) {
                        this.addSystemMessage(`Erro ao enviar mensagem privada: ${response.error}`);
                    }
                });
            }
            
            getRooms() {
                if (!this.connected) return;
                
                this.socket.emit('get_rooms', {}, (response) => {
                    if (response.rooms) {
                        this.addSystemMessage('=== Salas Dispon√≠veis ===');
                        response.rooms.forEach(room => {
                            this.addSystemMessage(`‚Ä¢ ${room.name} (${room.users_count} usu√°rios)`);
                        });
                        this.addSystemMessage('=== Fim da lista ===');
                    }
                });
            }
            
            disconnect() {
                if (this.socket) {
                    this.socket.disconnect();
                    this.socket = null;
                }
            }
            
            // M√©todos de UI
            addChatMessage(data) {
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';
                messageDiv.innerHTML = `
                    <span class="timestamp">[${timestamp}]</span>
                    <span class="username">${data.username}:</span>
                    ${data.message}
                `;
                this.chatMessages.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            addPrivateMessage(data) {
                const timestamp = new Date(data.timestamp).toLocaleTimeString();
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message private';
                messageDiv.innerHTML = `
                    <span class="timestamp">[${timestamp}]</span>
                    <strong>üîí Privado ${data.from} ‚Üí ${data.to}:</strong>
                    ${data.message}
                `;
                this.chatMessages.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            addSystemMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message system';
                messageDiv.textContent = `‚ÑπÔ∏è ${message}`;
                this.chatMessages.appendChild(messageDiv);
                this.scrollToBottom();
            }
            
            updateUsersList(users) {
                const usersList = document.getElementById('users-list');
                usersList.innerHTML = '';
                
                if (users.length > 0) {
                    this.usersOnline.style.display = 'block';
                    users.forEach(user => {
                        const userDiv = document.createElement('div');
                        const rooms = user.rooms.length > 0 ? ` (${user.rooms.join(', ')})` : '';
                        userDiv.textContent = `‚Ä¢ ${user.username}${rooms}`;
                        usersList.appendChild(userDiv);
                    });
                } else {
                    this.usersOnline.style.display = 'none';
                }
            }
            
            enableControls(enabled) {
                this.messageInput.disabled = !enabled;
                this.sendBtn.disabled = !enabled;
            }
            
            scrollToBottom() {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }
        }
        
        // Inst√¢ncia global do cliente
        const chatClient = new ChatClient();
        
        // Fun√ß√µes globais para os bot√µes
        function connectToServer() {
            const username = document.getElementById('username-input').value.trim();
            if (!username) {
                alert('Digite um nome de usu√°rio');
                return;
            }
            chatClient.connect(username);
        }
        
        function disconnectFromServer() {
            chatClient.disconnect();
        }
        
        function joinRoom() {
            const roomName = document.getElementById('room-input').value.trim();
            if (!roomName) {
                alert('Digite o nome da sala');
                return;
            }
            chatClient.joinRoom(roomName);
        }
        
        function sendMessage() {
            chatClient.sendMessage();
        }
        
        function sendPrivateMessage() {
            const targetUser = document.getElementById('private-user').value.trim();
            const message = document.getElementById('private-message').value.trim();
            
            if (!targetUser || !message) {
                alert('Digite o usu√°rio e a mensagem');
                return;
            }
            
            chatClient.sendPrivateMessage(targetUser, message);
            document.getElementById('private-message').value = '';
        }
        
        function listRooms() {
            chatClient.getRooms();
        }
    </script>
</body>
</html>
</code></pre>
                </div>
            </section>

            <!-- Chat Demo -->
            <section id="chat-demo" class="section hidden">
                <h2 class="text-3xl font-bold mb-6 text-primary">
                    <i class="fas fa-comments mr-3"></i>Demo de Chat em Tempo Real
                </h2>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">Simulador de Chat (Demonstra√ß√£o)</h3>
                    
                    <!-- Chat Interface -->
                    <div class="border border-gray-300 dark:border-gray-600 rounded-lg">
                        <!-- Chat Header -->
                        <div class="bg-primary text-white p-4 rounded-t-lg flex justify-between items-center">
                            <div class="flex items-center">
                                <i class="fas fa-comments mr-2"></i>
                                <span>Sala: <span id="demo-room-name">Geral</span></span>
                            </div>
                            <div class="flex items-center space-x-4">
                                <span id="demo-users-count">3 usu√°rios online</span>
                                <div id="demo-connection-status" class="w-3 h-3 bg-green-400 rounded-full"></div>
                            </div>
                        </div>
                        
                        <!-- Messages Area -->
                        <div id="demo-chat-messages" class="h-64 overflow-y-auto p-4 bg-gray-50 dark:bg-gray-800">
                            <!-- Mensagens ser√£o adicionadas aqui -->
                        </div>
                        
                        <!-- Input Area -->
                        <div class="p-4 border-t border-gray-300 dark:border-gray-600">
                            <div class="flex space-x-2">
                                <input 
                                    type="text" 
                                    id="demo-message-input" 
                                    placeholder="Digite sua mensagem..." 
                                    class="flex-1 text-base px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:text-white"
                                >
                                <button 
                                    onclick="sendDemoMessage()" 
                                    class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-purple-600 transition-colors"
                                >
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Demo Controls -->
                    <div class="mt-4 flex flex-wrap gap-2">
                        <button onclick="simulateUserJoin()" class="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600">
                            <i class="fas fa-user-plus mr-1"></i>Simular Entrada
                        </button>
                        <button onclick="simulateSystemMessage()" class="px-3 py-2 bg-yellow-500 text-white rounded hover:bg-yellow-600">
                            <i class="fas fa-exclamation-triangle mr-1"></i>Mensagem Sistema
                        </button>
                        <button onclick="simulatePrivateMessage()" class="px-3 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">
                            <i class="fas fa-lock mr-1"></i>Mensagem Privada
                        </button>
                        <button onclick="clearDemoChat()" class="px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600">
                            <i class="fas fa-trash mr-1"></i>Limpar Chat
                        </button>
                    </div>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">Chat em Flask com Socket.IO</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># app.py - Chat completo com Flask-SocketIO
from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit, join_room, leave_room, rooms
import json
from datetime import datetime
import uuid

app = Flask(__name__)
app.config['SECRET_KEY'] = 'sua_chave_secreta_aqui'

# Configura√ß√£o do SocketIO
socketio = SocketIO(
    app, 
    cors_allowed_origins="*",
    async_mode='threading'
)

# Armazenamento em mem√≥ria (use Redis em produ√ß√£o)
users_online = {}
chat_rooms = {
    'geral': {'users': set(), 'messages': []},
    'python': {'users': set(), 'messages': []},
    'tecnologia': {'users': set(), 'messages': []}
}

@app.route('/')
def index():
    """P√°gina principal do chat"""
    return render_template('chat.html')

@app.route('/api/rooms')
def get_rooms():
    """API para listar salas"""
    rooms_info = []
    for room_name, room_data in chat_rooms.items():
        rooms_info.append({
            'name': room_name,
            'users_count': len(room_data['users']),
            'last_activity': datetime.now().isoformat()
        })
    return {'rooms': rooms_info}

@socketio.on('connect')
def handle_connect(auth):
    """Usu√°rio conectou"""
    user_id = request.sid
    username = auth.get('username', f'Usuario_{user_id[:8]}') if auth else f'Usuario_{user_id[:8]}'
    
    # Registra usu√°rio
    users_online[user_id] = {
        'username': username,
        'connected_at': datetime.now(),
        'current_room': None
    }
    
    print(f"‚úÖ {username} conectou (ID: {user_id})")
    
    # Notifica cliente sobre conex√£o bem-sucedida
    emit('connected', {
        'user_id': user_id,
        'username': username,
        'timestamp': datetime.now().isoformat()
    })
    
    # Atualiza contadores globais
    update_users_count()

@socketio.on('disconnect')
def handle_disconnect():
    """Usu√°rio desconectou"""
    user_id = request.sid
    
    if user_id in users_online:
        username = users_online[user_id]['username']
        current_room = users_online[user_id]['current_room']
        
        # Remove das salas
        if current_room and current_room in chat_rooms:
            chat_rooms[current_room]['users'].discard(user_id)
            emit('user_left', {
                'username': username,
                'room': current_room,
                'timestamp': datetime.now().isoformat()
            }, room=current_room)
        
        # Remove do registro
        del users_online[user_id]
        print(f"‚ùå {username} desconectou")
        
        update_users_count()

@socketio.on('join_room')
def handle_join_room(data):
    """Usu√°rio entra em uma sala"""
    user_id = request.sid
    room_name = data.get('room', 'geral')
    
    if user_id not in users_online:
        emit('error', {'message': 'Usu√°rio n√£o autenticado'})
        return
    
    username = users_online[user_id]['username']
    
    # Cria sala se n√£o existir
    if room_name not in chat_rooms:
        chat_rooms[room_name] = {'users': set(), 'messages': []}
    
    # Sai da sala anterior
    previous_room = users_online[user_id]['current_room']
    if previous_room and previous_room in chat_rooms:
        leave_room(previous_room)
        chat_rooms[previous_room]['users'].discard(user_id)
        emit('user_left', {
            'username': username,
            'room': previous_room,
            'timestamp': datetime.now().isoformat()
        }, room=previous_room)
    
    # Entra na nova sala
    join_room(room_name)
    chat_rooms[room_name]['users'].add(user_id)
    users_online[user_id]['current_room'] = room_name
    
    # Notifica outros usu√°rios
    emit('user_joined', {
        'username': username,
        'room': room_name,
        'timestamp': datetime.now().isoformat()
    }, room=room_name, include_self=False)
    
    # Envia hist√≥rico para o usu√°rio
    recent_messages = chat_rooms[room_name]['messages'][-20:]
    emit('room_history', {
        'room': room_name,
        'messages': recent_messages
    })
    
    # Confirma entrada na sala
    emit('joined_room', {
        'room': room_name,
        'users_count': len(chat_rooms[room_name]['users'])
    })
    
    print(f"üè† {username} entrou na sala '{room_name}'")

@socketio.on('send_message')
def handle_send_message(data):
    """Usu√°rio envia mensagem"""
    user_id = request.sid
    message = data.get('message', '').strip()
    
    if user_id not in users_online:
        emit('error', {'message': 'Usu√°rio n√£o autenticado'})
        return
    
    if not message:
        emit('error', {'message': 'Mensagem vazia'})
        return
    
    user_data = users_online[user_id]
    username = user_data['username']
    room_name = user_data['current_room']
    
    if not room_name:
        emit('error', {'message': 'N√£o est√° em nenhuma sala'})
        return
    
    # Cria dados da mensagem
    message_data = {
        'id': str(uuid.uuid4()),
        'user_id': user_id,
        'username': username,
        'message': message,
        'timestamp': datetime.now().isoformat(),
        'room': room_name
    }
    
    # Armazena mensagem
    chat_rooms[room_name]['messages'].append(message_data)
    
    # Mant√©m apenas √∫ltimas 100 mensagens por sala
    if len(chat_rooms[room_name]['messages']) > 100:
        chat_rooms[room_name]['messages'] = chat_rooms[room_name]['messages'][-100:]
    
    # Envia para todos na sala
    emit('new_message', message_data, room=room_name)
    
    print(f"üí¨ [{room_name}] {username}: {message}")

@socketio.on('private_message')
def handle_private_message(data):
    """Mensagem privada entre usu√°rios"""
    sender_id = request.sid
    target_username = data.get('target_user')
    message = data.get('message', '').strip()
    
    if sender_id not in users_online:
        emit('error', {'message': 'Usu√°rio n√£o autenticado'})
        return
    
    if not message:
        emit('error', {'message': 'Mensagem vazia'})
        return
    
    # Encontra usu√°rio alvo
    target_id = None
    for uid, user_data in users_online.items():
        if user_data['username'] == target_username:
            target_id = uid
            break
    
    if not target_id:
        emit('error', {'message': 'Usu√°rio n√£o encontrado'})
        return
    
    sender_username = users_online[sender_id]['username']
    
    message_data = {
        'id': str(uuid.uuid4()),
        'from': sender_username,
        'to': target_username,
        'message': message,
        'timestamp': datetime.now().isoformat(),
        'type': 'private'
    }
    
    # Envia para ambos os usu√°rios
    emit('private_message', message_data, room=target_id)
    emit('private_message', message_data, room=sender_id)
    
    print(f"üîí {sender_username} ‚Üí {target_username}: {message}")

@socketio.on('typing_start')
def handle_typing_start(data):
    """Usu√°rio come√ßou a digitar"""
    user_id = request.sid
    if user_id in users_online:
        username = users_online[user_id]['username']
        room_name = users_online[user_id]['current_room']
        
        if room_name:
            emit('user_typing', {
                'username': username,
                'typing': True
            }, room=room_name, include_self=False)

@socketio.on('typing_stop')
def handle_typing_stop(data):
    """Usu√°rio parou de digitar"""
    user_id = request.sid
    if user_id in users_online:
        username = users_online[user_id]['username']
        room_name = users_online[user_id]['current_room']
        
        if room_name:
            emit('user_typing', {
                'username': username,
                'typing': False
            }, room=room_name, include_self=False)

def update_users_count():
    """Atualiza contador de usu√°rios para todos"""
    users_by_room = {}
    for user_id, user_data in users_online.items():
        room = user_data.get('current_room')
        if room:
            if room not in users_by_room:
                users_by_room[room] = []
            users_by_room[room].append({
                'username': user_data['username'],
                'connected_at': user_data['connected_at'].isoformat()
            })
    
    socketio.emit('users_update', {
        'total_online': len(users_online),
        'users_by_room': users_by_room
    })

if __name__ == '__main__':
    print("üöÄ Iniciando servidor Flask-SocketIO...")
    print("üì° Acesse: http://localhost:5000")
    
    socketio.run(
        app, 
        host='0.0.0.0', 
        port=5000, 
        debug=True,
        allow_unsafe_werkzeug=True
    )
</code></pre>
                </div>

                <div class="bg-yellow-50 dark:bg-yellow-900 border-l-4 border-yellow-400 p-6 rounded-lg">
                    <h3 class="text-lg font-semibold text-yellow-800 dark:text-yellow-200 mb-2">
                        <i class="fas fa-terminal mr-2"></i>Instala√ß√£o e Execu√ß√£o
                    </h3>
                    <div class="text-yellow-700 dark:text-yellow-300">
                        <pre class="bg-yellow-100 dark:bg-yellow-800 p-3 rounded text-sm"><code># Instala depend√™ncias
pip install flask flask-socketio

# Cria estrutura de pastas
mkdir templates static

# Executa o servidor
python app.py

# Acesse http://localhost:5000</code></pre>
                    </div>
                </div>
            </section>

            <!-- Apps Tempo Real -->
            <section id="real-time-apps" class="section hidden">
                <h2 class="text-3xl font-bold mb-6 text-primary">
                    <i class="fas fa-chart-line mr-3"></i>Aplica√ß√µes em Tempo Real
                </h2>

                <div class="grid md:grid-cols-2 gap-8 mb-8">
                    <!-- Dashboard em Tempo Real -->
                    <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                        <h3 class="text-xl font-bold mb-4 text-primary">
                            <i class="fas fa-tachometer-alt mr-2"></i>Dashboard em Tempo Real
                        </h3>
                        
                        <div class="space-y-4">
                            <!-- M√©tricas simuladas -->
                            <div class="grid grid-cols-2 gap-4">
                                <div class="bg-blue-100 dark:bg-blue-900 p-4 rounded-lg text-center">
                                    <div class="text-2xl font-bold text-blue-600" id="metric-users">0</div>
                                    <div class="text-sm text-blue-800 dark:text-blue-200">Usu√°rios Online</div>
                                </div>
                                <div class="bg-green-100 dark:bg-green-900 p-4 rounded-lg text-center">
                                    <div class="text-2xl font-bold text-green-600" id="metric-messages">0</div>
                                    <div class="text-sm text-green-800 dark:text-green-200">Mensagens/min</div>
                                </div>
                            </div>
                            
                            <!-- Gr√°fico simulado -->
                            <div class="bg-gray-100 dark:bg-gray-700 h-32 rounded-lg flex items-center justify-center">
                                <canvas id="dashboard-chart" width="300" height="120"></canvas>
                            </div>
                            
                            <!-- Log de atividades -->
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg h-24 overflow-y-auto text-xs">
                                <div id="activity-log">
                                    <div class="text-gray-500">Aguardando atividades...</div>
                                </div>
                            </div>
                            
                            <button onclick="toggleDashboard()" class="w-full bg-primary text-white py-2 rounded-lg hover:bg-purple-600 transition-colors">
                                <span id="dashboard-btn-text">Iniciar Dashboard</span>
                            </button>
                        </div>
                    </div>

                    <!-- Notifica√ß√µes Push -->
                    <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                        <h3 class="text-xl font-bold mb-4 text-primary">
                            <i class="fas fa-bell mr-2"></i>Sistema de Notifica√ß√µes
                        </h3>
                        
                        <div class="space-y-4">
                            <!-- Centro de notifica√ß√µes -->
                            <div id="notifications-container" class="space-y-2 max-h-48 overflow-y-auto">
                                <div class="text-gray-500 text-center py-4">
                                    Nenhuma notifica√ß√£o
                                </div>
                            </div>
                            
                            <!-- Controles -->
                            <div class="space-y-2">
                                <select id="notification-type" class="w-full text-base px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white">
                                    <option value="info">Informa√ß√£o</option>
                                    <option value="success">Sucesso</option>
                                    <option value="warning">Aviso</option>
                                    <option value="error">Erro</option>
                                </select>
                                
                                <input 
                                    type="text" 
                                    id="notification-message" 
                                    placeholder="Mensagem da notifica√ß√£o..." 
                                    class="w-full text-base px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg dark:bg-gray-700 dark:text-white"
                                >
                                
                                <button onclick="sendNotification()" class="w-full bg-green-500 text-white py-2 rounded-lg hover:bg-green-600 transition-colors">
                                    <i class="fas fa-paper-plane mr-2"></i>Enviar Notifica√ß√£o
                                </button>
                                
                                <button onclick="clearNotifications()" class="w-full bg-red-500 text-white py-2 rounded-lg hover:bg-red-600 transition-colors">
                                    <i class="fas fa-trash mr-2"></i>Limpar Todas
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">Sistema de Monitoramento em Tempo Real</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># monitor_sistema.py - Monitoramento de sistema em tempo real
import asyncio
import psutil
import json
import time
from datetime import datetime
import socketio
from typing import Dict, List

class SystemMonitor:
    def __init__(self):
        self.sio = socketio.AsyncServer(cors_allowed_origins="*")
        self.app = socketio.ASGIApp(self.sio)
        self.monitoring = False
        self.clients = set()
        
        # Hist√≥rico de m√©tricas
        self.metrics_history = {
            'cpu': [],
            'memory': [],
            'disk': [],
            'network': []
        }
        
        self.setup_events()
    
    def setup_events(self):
        @self.sio.event
        async def connect(sid, environ):
            self.clients.add(sid)
            print(f"Cliente conectado: {sid}")
            
            # Envia estado inicial
            await self.sio.emit('monitoring_status', {
                'active': self.monitoring,
                'clients_count': len(self.clients)
            }, room=sid)
            
            # Envia hist√≥rico recente
            await self.send_metrics_history(sid)
        
        @self.sio.event
        async def disconnect(sid):
            self.clients.discard(sid)
            print(f"Cliente desconectado: {sid}")
        
        @self.sio.event
        async def start_monitoring(sid):
            if not self.monitoring:
                self.monitoring = True
                asyncio.create_task(self.monitor_loop())
                await self.sio.emit('monitoring_started', {'timestamp': datetime.now().isoformat()})
        
        @self.sio.event
        async def stop_monitoring(sid):
            self.monitoring = False
            await self.sio.emit('monitoring_stopped', {'timestamp': datetime.now().isoformat()})
        
        @self.sio.event
        async def get_process_list(sid):
            processes = self.get_top_processes()
            await self.sio.emit('process_list', {'processes': processes}, room=sid)
    
    def get_system_metrics(self) -> Dict:
        """Coleta m√©tricas do sistema"""
        # CPU
        cpu_percent = psutil.cpu_percent(interval=1)
        cpu_count = psutil.cpu_count()
        cpu_freq = psutil.cpu_freq()
        
        # Mem√≥ria
        memory = psutil.virtual_memory()
        swap = psutil.swap_memory()
        
        # Disco
        disk = psutil.disk_usage('/')
        disk_io = psutil.disk_io_counters()
        
        # Rede
        network_io = psutil.net_io_counters()
        network_connections = len(psutil.net_connections())
        
        # Processos
        process_count = len(psutil.pids())
        
        # Temperatura (se dispon√≠vel)
        try:
            temperatures = psutil.sensors_temperatures()
            temp_avg = 0
            if temperatures:
                temp_values = []
                for name, entries in temperatures.items():
                    for entry in entries:
                        if entry.current:
                            temp_values.append(entry.current)
                temp_avg = sum(temp_values) / len(temp_values) if temp_values else 0
        except:
            temp_avg = 0
        
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'cpu': {
                'percent': cpu_percent,
                'count': cpu_count,
                'freq_current': cpu_freq.current if cpu_freq else 0,
                'freq_max': cpu_freq.max if cpu_freq else 0
            },
            'memory': {
                'total': memory.total,
                'available': memory.available,
                'percent': memory.percent,
                'used': memory.used,
                'free': memory.free,
                'swap_total': swap.total,
                'swap_used': swap.used,
                'swap_percent': swap.percent
            },
            'disk': {
                'total': disk.total,
                'used': disk.used,
                'free': disk.free,
                'percent': disk.percent,
                'read_bytes': disk_io.read_bytes if disk_io else 0,
                'write_bytes': disk_io.write_bytes if disk_io else 0
            },
            'network': {
                'bytes_sent': network_io.bytes_sent,
                'bytes_recv': network_io.bytes_recv,
                'packets_sent': network_io.packets_sent,
                'packets_recv': network_io.packets_recv,
                'connections': network_connections
            },
            'system': {
                'process_count': process_count,
                'temperature': temp_avg,
                'uptime': time.time() - psutil.boot_time()
            }
        }
        
        return metrics
    
    def get_top_processes(self, limit: int = 10) -> List[Dict]:
        """Retorna os processos que mais consomem recursos"""
        processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'status']):
            try:
                proc_info = proc.info
                proc_info['cpu_percent'] = proc.cpu_percent()
                processes.append(proc_info)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        
        # Ordena por CPU
        processes.sort(key=lambda x: x.get('cpu_percent', 0), reverse=True)
        
        return processes[:limit]
    
    async def monitor_loop(self):
        """Loop principal de monitoramento"""
        while self.monitoring and self.clients:
            try:
                # Coleta m√©tricas
                metrics = self.get_system_metrics()
                
                # Armazena no hist√≥rico (mant√©m √∫ltimas 100 entradas)
                for key in self.metrics_history:
                    if key in metrics:
                        self.metrics_history[key].append({
                            'timestamp': metrics['timestamp'],
                            'value': metrics[key]
                        })
                        
                        if len(self.metrics_history[key]) > 100:
                            self.metrics_history[key] = self.metrics_history[key][-100:]
                
                # Envia para todos os clientes
                await self.sio.emit('system_metrics', metrics)
                
                # Verifica alertas
                alerts = self.check_alerts(metrics)
                if alerts:
                    await self.sio.emit('system_alerts', {'alerts': alerts})
                
                # Aguarda pr√≥xima coleta
                await asyncio.sleep(2)
                
            except Exception as e:
                print(f"Erro no monitoramento: {e}")
                await asyncio.sleep(5)
        
        self.monitoring = False
    
    def check_alerts(self, metrics: Dict) -> List[Dict]:
        """Verifica condi√ß√µes de alerta"""
        alerts = []
        
        # CPU alto
        if metrics['cpu']['percent'] > 80:
            alerts.append({
                'type': 'warning',
                'title': 'CPU Alto',
                'message': f"Uso de CPU em {metrics['cpu']['percent']:.1f}%",
                'timestamp': datetime.now().isoformat()
            })
        
        # Mem√≥ria alta
        if metrics['memory']['percent'] > 85:
            alerts.append({
                'type': 'warning',
                'title': 'Mem√≥ria Alta',
                'message': f"Uso de mem√≥ria em {metrics['memory']['percent']:.1f}%",
                'timestamp': datetime.now().isoformat()
            })
        
        # Disco cheio
        if metrics['disk']['percent'] > 90:
            alerts.append({
                'type': 'error',
                'title': 'Disco Cheio',
                'message': f"Uso de disco em {metrics['disk']['percent']:.1f}%",
                'timestamp': datetime.now().isoformat()
            })
        
        # Temperatura alta
        if metrics['system']['temperature'] > 75:
            alerts.append({
                'type': 'warning',
                'title': 'Temperatura Alta',
                'message': f"Temperatura do sistema: {metrics['system']['temperature']:.1f}¬∞C",
                'timestamp': datetime.now().isoformat()
            })
        
        return alerts
    
    async def send_metrics_history(self, sid: str):
        """Envia hist√≥rico de m√©tricas para um cliente"""
        await self.sio.emit('metrics_history', {
            'history': self.metrics_history
        }, room=sid)

# Servidor de exemplo
if __name__ == "__main__":
    import uvicorn
    
    monitor = SystemMonitor()
    
    print("üñ•Ô∏è  Iniciando monitor de sistema...")
    print("üìä Acesse: http://localhost:8001")
    
    config = uvicorn.Config(
        app=monitor.app,
        host="0.0.0.0",
        port=8001,
        log_level="info"
    )
    
    server = uvicorn.Server(config)
    asyncio.run(server.serve())
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                    <h3 class="text-xl font-bold mb-4">Trading/Criptomoedas em Tempo Real</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># crypto_monitor.py - Monitor de criptomoedas em tempo real
import asyncio
import aiohttp
import json
from datetime import datetime
import socketio
from typing import Dict, List
import logging

class CryptoMonitor:
    def __init__(self):
        self.sio = socketio.AsyncServer(cors_allowed_origins="*")
        self.app = socketio.ASGIApp(self.sio)
        
        # Configura√ß√£o
        self.api_url = "https://api.coingecko.com/api/v3"
        self.coins_to_track = [
            'bitcoin', 'ethereum', 'binancecoin', 'cardano', 
            'solana', 'polkadot', 'dogecoin', 'avalanche-2'
        ]
        
        # Estado
        self.monitoring = False
        self.clients = {}
        self.price_history = {}
        self.alerts = {}
        
        self.setup_events()
    
    def setup_events(self):
        @self.sio.event
        async def connect(sid, environ, auth):
            user_id = auth.get('user_id', sid) if auth else sid
            self.clients[sid] = {
                'user_id': user_id,
                'connected_at': datetime.now(),
                'subscriptions': set(self.coins_to_track)  # Por padr√£o, todas as moedas
            }
            
            print(f"üì± Cliente conectado: {user_id}")
            
            # Envia dados iniciais
            await self.send_initial_data(sid)
        
        @self.sio.event
        async def disconnect(sid):
            if sid in self.clients:
                user_id = self.clients[sid]['user_id']
                del self.clients[sid]
                print(f"üì± Cliente desconectado: {user_id}")
        
        @self.sio.event
        async def subscribe_coin(sid, data):
            """Cliente se inscreve para uma moeda espec√≠fica"""
            coin_id = data.get('coin_id')
            if sid in self.clients and coin_id:
                self.clients[sid]['subscriptions'].add(coin_id)
                await self.sio.emit('subscription_updated', {
                    'coin_id': coin_id,
                    'subscribed': True
                }, room=sid)
        
        @self.sio.event
        async def unsubscribe_coin(sid, data):
            """Cliente cancela inscri√ß√£o de uma moeda"""
            coin_id = data.get('coin_id')
            if sid in self.clients and coin_id:
                self.clients[sid]['subscriptions'].discard(coin_id)
                await self.sio.emit('subscription_updated', {
                    'coin_id': coin_id,
                    'subscribed': False
                }, room=sid)
        
        @self.sio.event
        async def set_price_alert(sid, data):
            """Define alerta de pre√ßo"""
            coin_id = data.get('coin_id')
            price_target = data.get('price_target')
            alert_type = data.get('type', 'above')  # 'above' ou 'below'
            
            if sid in self.clients and coin_id and price_target:
                user_id = self.clients[sid]['user_id']
                
                if user_id not in self.alerts:
                    self.alerts[user_id] = {}
                
                alert_id = f"{coin_id}_{alert_type}_{price_target}"
                self.alerts[user_id][alert_id] = {
                    'coin_id': coin_id,
                    'price_target': float(price_target),
                    'type': alert_type,
                    'created_at': datetime.now().isoformat(),
                    'triggered': False
                }
                
                await self.sio.emit('alert_set', {
                    'alert_id': alert_id,
                    'coin_id': coin_id,
                    'price_target': price_target,
                    'type': alert_type
                }, room=sid)
        
        @self.sio.event
        async def get_coin_history(sid, data):
            """Retorna hist√≥rico de uma moeda"""
            coin_id = data.get('coin_id')
            if coin_id in self.price_history:
                await self.sio.emit('coin_history', {
                    'coin_id': coin_id,
                    'history': self.price_history[coin_id][-100:]  # √öltimos 100 pontos
                }, room=sid)
    
    async def fetch_crypto_prices(self) -> Dict:
        """Busca pre√ßos das criptomoedas"""
        try:
            coins_str = ','.join(self.coins_to_track)
            url = f"{self.api_url}/simple/price"
            params = {
                'ids': coins_str,
                'vs_currencies': 'usd,brl',
                'include_24hr_change': 'true',
                'include_24hr_vol': 'true',
                'include_market_cap': 'true'
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        # Processa dados
                        processed_data = {}
                        timestamp = datetime.now().isoformat()
                        
                        for coin_id, coin_data in data.items():
                            processed_data[coin_id] = {
                                'id': coin_id,
                                'name': coin_id.replace('-', ' ').title(),
                                'price_usd': coin_data.get('usd', 0),
                                'price_brl': coin_data.get('brl', 0),
                                'change_24h': coin_data.get('usd_24h_change', 0),
                                'volume_24h': coin_data.get('usd_24h_vol', 0),
                                'market_cap': coin_data.get('usd_market_cap', 0),
                                'timestamp': timestamp
                            }
                            
                            # Armazena no hist√≥rico
                            if coin_id not in self.price_history:
                                self.price_history[coin_id] = []
                            
                            self.price_history[coin_id].append({
                                'timestamp': timestamp,
                                'price_usd': coin_data.get('usd', 0),
                                'price_brl': coin_data.get('brl', 0),
                                'volume': coin_data.get('usd_24h_vol', 0)
                            })
                            
                            # Mant√©m apenas √∫ltimos 500 pontos
                            if len(self.price_history[coin_id]) > 500:
                                self.price_history[coin_id] = self.price_history[coin_id][-500:]
                        
                        return processed_data
                    
                    else:
                        print(f"Erro na API: {response.status}")
                        return {}
                        
        except Exception as e:
            print(f"Erro ao buscar pre√ßos: {e}")
            return {}
    
    async def check_price_alerts(self, prices: Dict):
        """Verifica alertas de pre√ßo"""
        for user_id, user_alerts in self.alerts.items():
            for alert_id, alert_data in user_alerts.items():
                if alert_data['triggered']:
                    continue
                
                coin_id = alert_data['coin_id']
                if coin_id not in prices:
                    continue
                
                current_price = prices[coin_id]['price_usd']
                target_price = alert_data['price_target']
                alert_type = alert_data['type']
                
                triggered = False
                if alert_type == 'above' and current_price >= target_price:
                    triggered = True
                elif alert_type == 'below' and current_price <= target_price:
                    triggered = True
                
                if triggered:
                    alert_data['triggered'] = True
                    alert_data['triggered_at'] = datetime.now().isoformat()
                    alert_data['triggered_price'] = current_price
                    
                    # Envia alerta para o usu√°rio
                    for sid, client_data in self.clients.items():
                        if client_data['user_id'] == user_id:
                            await self.sio.emit('price_alert_triggered', {
                                'alert_id': alert_id,
                                'coin_id': coin_id,
                                'coin_name': prices[coin_id]['name'],
                                'current_price': current_price,
                                'target_price': target_price,
                                'type': alert_type,
                                'timestamp': alert_data['triggered_at']
                            }, room=sid)
    
    async def send_initial_data(self, sid: str):
        """Envia dados iniciais para um cliente"""
        # Dados das moedas
        if self.price_history:
            latest_prices = {}
            for coin_id in self.coins_to_track:
                if coin_id in self.price_history and self.price_history[coin_id]:
                    latest_prices[coin_id] = self.price_history[coin_id][-1]
            
            await self.sio.emit('initial_data', {
                'prices': latest_prices,
                'monitoring': self.monitoring
            }, room=sid)
    
    async def monitor_loop(self):
        """Loop principal de monitoramento"""
        self.monitoring = True
        
        while self.monitoring and self.clients:
            try:
                # Busca pre√ßos atualizados
                prices = await self.fetch_crypto_prices()
                
                if prices:
                    # Verifica alertas
                    await self.check_price_alerts(prices)
                    
                    # Envia atualiza√ß√µes para clientes
                    for sid, client_data in self.clients.items():
                        subscriptions = client_data['subscriptions']
                        
                        # Filtra apenas moedas inscritas
                        filtered_prices = {
                            coin_id: price_data 
                            for coin_id, price_data in prices.items()
                            if coin_id in subscriptions
                        }
                        
                        if filtered_prices:
                            await self.sio.emit('price_update', {
                                'prices': filtered_prices,
                                'timestamp': datetime.now().isoformat()
                            }, room=sid)
                
                # Aguarda pr√≥xima atualiza√ß√£o (30 segundos)
                await asyncio.sleep(30)
                
            except Exception as e:
                print(f"Erro no loop de monitoramento: {e}")
                await asyncio.sleep(60)  # Aguarda mais tempo em caso de erro
        
        self.monitoring = False
    
    async def start_monitoring(self):
        """Inicia o monitoramento"""
        if not self.monitoring:
            asyncio.create_task(self.monitor_loop())

# Execu√ß√£o
if __name__ == "__main__":
    import uvicorn
    
    crypto_monitor = CryptoMonitor()
    
    # Inicia monitoramento
    asyncio.create_task(crypto_monitor.start_monitoring())
    
    print("üí∞ Iniciando monitor de criptomoedas...")
    print("üìä Acesse: http://localhost:8002")
    
    config = uvicorn.Config(
        app=crypto_monitor.app,
        host="0.0.0.0",
        port=8002,
        log_level="info"
    )
    
    server = uvicorn.Server(config)
    asyncio.run(server.serve())
</code></pre>
                </div>
            </section>

            <!-- Produ√ß√£o -->
            <section id="production" class="section hidden">
                <h2 class="text-3xl font-bold mb-6 text-primary">
                    <i class="fas fa-server mr-3"></i>Deploy em Produ√ß√£o
                </h2>

                <div class="bg-gradient-to-r from-red-500 to-orange-500 text-white rounded-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-2">
                        <i class="fas fa-exclamation-triangle mr-2"></i>Considera√ß√µes Cr√≠ticas para Produ√ß√£o
                    </h3>
                    <div class="grid md:grid-cols-2 gap-4">
                        <div>
                            <i class="fas fa-shield-alt mr-2"></i>Seguran√ßa e autentica√ß√£o<br>
                            <i class="fas fa-expand-arrows-alt mr-2"></i>Escalabilidade horizontal<br>
                            <i class="fas fa-database mr-2"></i>Persist√™ncia de dados<br>
                            <i class="fas fa-tachometer-alt mr-2"></i>Monitoramento e m√©tricas
                        </div>
                        <div>
                            <i class="fas fa-balance-scale mr-2"></i>Load balancing<br>
                            <i class="fas fa-redo mr-2"></i>Recupera√ß√£o de falhas<br>
                            <i class="fas fa-lock mr-2"></i>Rate limiting<br>
                            <i class="fas fa-cogs mr-2"></i>CI/CD pipeline
                        </div>
                    </div>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">1. Configura√ß√£o Docker Completa</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-dockerfile"># Dockerfile
FROM python:3.11-slim

# Instala depend√™ncias do sistema
RUN apt-get update && apt-get install -y \
    gcc \
    redis-tools \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Configura usu√°rio n√£o-root
RUN useradd --create-home --shell /bin/bash app
WORKDIR /home/app

# Instala depend√™ncias Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copia c√≥digo da aplica√ß√£o
COPY --chown=app:app . .

# Muda para usu√°rio n√£o-root
USER app

# Porta da aplica√ß√£o
EXPOSE 8000

# Comando de execu√ß√£o
CMD ["gunicorn", "--worker-class", "eventlet", "-w", "1", "--bind", "0.0.0.0:8000", "app:app"]
</code></pre>

                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto mt-4"><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  # Aplica√ß√£o principal
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/realtime_db
      - SECRET_KEY=${SECRET_KEY}
      - DEBUG=false
    depends_on:
      - redis
      - postgres
    restart: unless-stopped
    volumes:
      - ./logs:/home/app/logs
    networks:
      - app-network

  # Redis para cache e pub/sub
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - app-network

  # PostgreSQL para dados persistentes
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=realtime_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    networks:
      - app-network

  # Nginx como proxy reverso
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
    networks:
      - app-network

  # Monitoramento com Prometheus
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
    networks:
      - app-network

  # Grafana para dashboards
  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - app-network

volumes:
  redis_data:
  postgres_data:
  prometheus_data:
  grafana_data:

networks:
  app-network:
    driver: bridge
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6 mb-8">
                    <h3 class="text-xl font-bold mb-4">2. Aplica√ß√£o Escal√°vel com Redis</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-python"># app.py - Aplica√ß√£o escal√°vel para produ√ß√£o
import os
import redis
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json
import jwt
from functools import wraps

import socketio
from aioredis import Redis
import asyncpg
from fastapi import FastAPI, HTTPException, Depends, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Configura√ß√£o de logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configura√ß√µes de ambiente
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379')
DATABASE_URL = os.getenv('DATABASE_URL', 'postgresql://postgres:password@localhost:5432/realtime_db')
SECRET_KEY = os.getenv('SECRET_KEY', 'sua-chave-secreta-super-segura')
DEBUG = os.getenv('DEBUG', 'false').lower() == 'true'

class ProductionSocketIOServer:
    def __init__(self):
        # Redis para pub/sub entre inst√¢ncias
        self.redis_client = None
        self.db_pool = None
        
        # Socket.IO com Redis adapter
        self.sio = socketio.AsyncServer(
            cors_allowed_origins="*" if DEBUG else ["https://seudominio.com"],
            async_mode='asgi',
            redis_url=REDIS_URL,
            logger=DEBUG,
            engineio_logger=DEBUG
        )
        
        # FastAPI para APIs REST
        self.app = FastAPI(title="Realtime API", debug=DEBUG)
        self.security = HTTPBearer()
        
        # Configura√ß√µes de CORS
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"] if DEBUG else ["https://seudominio.com"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # M√©tricas e rate limiting
        self.metrics = {
            'connections': 0,
            'messages_sent': 0,
            'messages_received': 0,
            'errors': 0
        }
        
        self.rate_limits = {}  # {user_id: {action: [timestamps]}}
        
        self.setup_events()
        self.setup_routes()
    
    async def init_services(self):
        """Inicializa servi√ßos externos"""
        try:
            # Redis
            self.redis_client = redis.from_url(REDIS_URL)
            await self.redis_client.ping()
            logger.info("‚úÖ Redis conectado")
            
            # PostgreSQL
            self.db_pool = await asyncpg.create_pool(DATABASE_URL)
            logger.info("‚úÖ PostgreSQL conectado")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao conectar servi√ßos: {e}")
            raise
    
    def verify_jwt_token(self, credentials: HTTPAuthorizationCredentials = Security(HTTPBearer())):
        """Verifica token JWT"""
        try:
            token = credentials.credentials
            payload = jwt.decode(token, SECRET_KEY, algorithms=['HS256'])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token expirado")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Token inv√°lido")
    
    def check_rate_limit(self, user_id: str, action: str, limit: int = 60, window: int = 60) -> bool:
        """Verifica rate limiting"""
        now = datetime.now()
        window_start = now - timedelta(seconds=window)
        
        if user_id not in self.rate_limits:
            self.rate_limits[user_id] = {}
        
        if action not in self.rate_limits[user_id]:
            self.rate_limits[user_id][action] = []
        
        # Remove timestamps antigos
        self.rate_limits[user_id][action] = [
            ts for ts in self.rate_limits[user_id][action] 
            if ts > window_start
        ]
        
        # Verifica limite
        if len(self.rate_limits[user_id][action]) >= limit:
            return False
        
        # Adiciona timestamp atual
        self.rate_limits[user_id][action].append(now)
        return True
    
    def setup_events(self):
        @self.sio.event
        async def connect(sid, environ, auth):
            """Evento de conex√£o com autentica√ß√£o"""
            try:
                # Verifica autentica√ß√£o
                if not auth or 'token' not in auth:
                    logger.warning(f"Conex√£o rejeitada - sem token: {sid}")
                    return False
                
                # Valida token
                try:
                    payload = jwt.decode(auth['token'], SECRET_KEY, algorithms=['HS256'])
                    user_id = payload.get('user_id')
                    username = payload.get('username')
                    
                    if not user_id or not username:
                        logger.warning(f"Token inv√°lido - dados faltando: {sid}")
                        return False
                        
                except jwt.InvalidTokenError as e:
                    logger.warning(f"Token JWT inv√°lido: {e}")
                    return False
                
                # Rate limiting para conex√µes
                if not self.check_rate_limit(user_id, 'connect', limit=10, window=60):
                    logger.warning(f"Rate limit excedido para conex√£o: {user_id}")
                    return False
                
                # Armazena dados do usu√°rio na sess√£o
                async with self.sio.session(sid) as session:
                    session['user_id'] = user_id
                    session['username'] = username
                    session['connected_at'] = datetime.now().isoformat()
                
                # Armazena no Redis para compartilhamento entre inst√¢ncias
                user_data = {
                    'sid': sid,
                    'user_id': user_id,
                    'username': username,
                    'connected_at': datetime.now().isoformat(),
                    'instance': os.getpid()  # ID da inst√¢ncia
                }
                
                await self.redis_client.hset(
                    f"user_sessions:{user_id}", 
                    sid, 
                    json.dumps(user_data)
                )
                
                # M√©tricas
                self.metrics['connections'] += 1
                
                logger.info(f"‚úÖ Usu√°rio conectado: {username} ({user_id}) - SID: {sid}")
                
                # Envia confirma√ß√£o
                await self.sio.emit('authenticated', {
                    'user_id': user_id,
                    'username': username,
                    'server_time': datetime.now().isoformat()
                }, room=sid)
                
                return True
                
            except Exception as e:
                logger.error(f"Erro na conex√£o: {e}")
                self.metrics['errors'] += 1
                return False
        
        @self.sio.event
        async def disconnect(sid):
            """Evento de desconex√£o"""
            try:
                # Recupera dados da sess√£o
                async with self.sio.session(sid) as session:
                    user_id = session.get('user_id')
                    username = session.get('username')
                
                if user_id:
                    # Remove do Redis
                    await self.redis_client.hdel(f"user_sessions:{user_id}", sid)
                    
                    # Se n√£o h√° mais sess√µes ativas, remove usu√°rio completamente
                    sessions = await self.redis_client.hgetall(f"user_sessions:{user_id}")
                    if not sessions:
                        await self.redis_client.delete(f"user_sessions:{user_id}")
                    
                    logger.info(f"‚ùå Usu√°rio desconectado: {username} ({user_id})")
                
                self.metrics['connections'] -= 1
                
            except Exception as e:
                logger.error(f"Erro na desconex√£o: {e}")
        
        @self.sio.event
        async def join_room(sid, data):
            """Usu√°rio entra em uma sala"""
            try:
                async with self.sio.session(sid) as session:
                    user_id = session.get('user_id')
                    username = session.get('username')
                
                if not user_id:
                    await self.sio.emit('error', {'message': 'N√£o autenticado'}, room=sid)
                    return
                
                room_name = data.get('room', '').strip()
                if not room_name:
                    await self.sio.emit('error', {'message': 'Nome da sala inv√°lido'}, room=sid)
                    return
                
                # Rate limiting
                if not self.check_rate_limit(user_id, 'join_room', limit=20, window=60):
                    await self.sio.emit('error', {'message': 'Rate limit excedido'}, room=sid)
                    return
                
                # Valida permiss√£o (implementar l√≥gica de neg√≥cio)
                if not await self.user_can_join_room(user_id, room_name):
                    await self.sio.emit('error', {'message': 'Sem permiss√£o para esta sala'}, room=sid)
                    return
                
                # Entra na sala
                await self.sio.enter_room(sid, room_name)
                
                # Armazena no banco de dados
                async with self.db_pool.acquire() as conn:
                    await conn.execute("""
                        INSERT INTO room_memberships (user_id, room_name, joined_at)
                        VALUES ($1, $2, $3)
                        ON CONFLICT (user_id, room_name) 
                        DO UPDATE SET joined_at = $3
                    """, user_id, room_name, datetime.now())
                
                # Notifica outros usu√°rios
                await self.sio.emit('user_joined', {
                    'user_id': user_id,
                    'username': username,
                    'room': room_name,
                    'timestamp': datetime.now().isoformat()
                }, room=room_name, skip_sid=sid)
                
                # Confirma para o usu√°rio
                await self.sio.emit('joined_room', {
                    'room': room_name,
                    'timestamp': datetime.now().isoformat()
                }, room=sid)
                
                logger.info(f"üè† {username} entrou na sala {room_name}")
                
            except Exception as e:
                logger.error(f"Erro ao entrar na sala: {e}")
                await self.sio.emit('error', {'message': 'Erro interno'}, room=sid)
                self.metrics['errors'] += 1
        
        @self.sio.event
        async def send_message(sid, data):
            """Envia mensagem para uma sala"""
            try:
                async with self.sio.session(sid) as session:
                    user_id = session.get('user_id')
                    username = session.get('username')
                
                if not user_id:
                    await self.sio.emit('error', {'message': 'N√£o autenticado'}, room=sid)
                    return
                
                room_name = data.get('room', '').strip()
                message = data.get('message', '').strip()
                
                if not room_name or not message:
                    await self.sio.emit('error', {'message': 'Dados inv√°lidos'}, room=sid)
                    return
                
                # Rate limiting para mensagens
                if not self.check_rate_limit(user_id, 'send_message', limit=30, window=60):
                    await self.sio.emit('error', {'message': 'Muitas mensagens. Aguarde.'}, room=sid)
                    return
                
                # Valida√ß√£o de conte√∫do (implementar filtros)
                if not await self.validate_message_content(message):
                    await self.sio.emit('error', {'message': 'Mensagem cont√©m conte√∫do proibido'}, room=sid)
                    return
                
                # Verifica se usu√°rio est√° na sala
                if not await self.user_in_room(user_id, room_name):
                    await self.sio.emit('error', {'message': 'Voc√™ n√£o est√° nesta sala'}, room=sid)
                    return
                
                # Cria mensagem
                message_id = await self.save_message(user_id, room_name, message)
                
                message_data = {
                    'id': message_id,
                    'user_id': user_id,
                    'username': username,
                    'message': message,
                    'room': room_name,
                    'timestamp': datetime.now().isoformat()
                }
                
                # Envia para todos na sala
                await self.sio.emit('new_message', message_data, room=room_name)
                
                # M√©tricas
                self.metrics['messages_sent'] += 1
                self.metrics['messages_received'] += 1
                
                logger.info(f"üí¨ [{room_name}] {username}: {message[:50]}...")
                
            except Exception as e:
                logger.error(f"Erro ao enviar mensagem: {e}")
                await self.sio.emit('error', {'message': 'Erro interno'}, room=sid)
                self.metrics['errors'] += 1
    
    async def user_can_join_room(self, user_id: str, room_name: str) -> bool:
        """Verifica se usu√°rio pode entrar na sala"""
        # Implementar l√≥gica de neg√≥cio espec√≠fica
        # Ex: salas privadas, banimentos, etc.
        return True
    
    async def user_in_room(self, user_id: str, room_name: str) -> bool:
        """Verifica se usu√°rio est√° na sala"""
        async with self.db_pool.acquire() as conn:
            result = await conn.fetchval("""
                SELECT EXISTS(
                    SELECT 1 FROM room_memberships 
                    WHERE user_id = $1 AND room_name = $2
                )
            """, user_id, room_name)
            return result
    
    async def validate_message_content(self, message: str) -> bool:
        """Valida conte√∫do da mensagem"""
        # Implementar filtros de spam, palavr√µes, etc.
        if len(message) > 1000:  # Limite de caracteres
            return False
        
        # Lista de palavras proibidas (exemplo simplificado)
        forbidden_words = ['spam', 'hack', 'phishing']
        message_lower = message.lower()
        
        for word in forbidden_words:
            if word in message_lower:
                return False
        
        return True
    
    async def save_message(self, user_id: str, room_name: str, message: str) -> str:
        """Salva mensagem no banco de dados"""
        async with self.db_pool.acquire() as conn:
            message_id = await conn.fetchval("""
                INSERT INTO messages (user_id, room_name, content, created_at)
                VALUES ($1, $2, $3, $4)
                RETURNING id
            """, user_id, room_name, message, datetime.now())
            
            return str(message_id)
    
    def setup_routes(self):
        """Configura rotas da API REST"""
        
        @self.app.get("/health")
        async def health_check():
            """Health check para load balancer"""
            return {
                "status": "healthy",
                "timestamp": datetime.now().isoformat(),
                "metrics": self.metrics
            }
        
        @self.app.get("/metrics")
        async def get_metrics():
            """M√©tricas da aplica√ß√£o"""
            return {
                "metrics": self.metrics,
                "redis_info": await self.get_redis_info(),
                "db_pool_info": {
                    "size": self.db_pool.get_size(),
                    "max_size": self.db_pool.get_max_size(),
                    "min_size": self.db_pool.get_min_size()
                }
            }
        
        @self.app.post("/auth/token")
        async def create_token(user_data: dict):
            """Cria token JWT (implementar autentica√ß√£o real)"""
            # Em produ√ß√£o, verificar credenciais no banco
            payload = {
                'user_id': user_data.get('user_id'),
                'username': user_data.get('username'),
                'exp': datetime.utcnow() + timedelta(hours=24)
            }
            
            token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')
            return {"access_token": token, "token_type": "bearer"}
    
    async def get_redis_info(self):
        """Informa√ß√µes do Redis"""
        try:
            info = await self.redis_client.info()
            return {
                "connected_clients": info.get('connected_clients'),
                "used_memory_human": info.get('used_memory_human'),
                "total_commands_processed": info.get('total_commands_processed')
            }
        except:
            return {"error": "Redis n√£o dispon√≠vel"}

# Inicializa√ß√£o da aplica√ß√£o
server = ProductionSocketIOServer()
app = socketio.ASGIApp(server.sio, server.app)

@app.on_event("startup")
async def startup_event():
    await server.init_services()

if __name__ == "__main__":
    config = uvicorn.Config(
        app=app,
        host="0.0.0.0",
        port=8000,
        log_level="info",
        access_log=True
    )
    
    server = uvicorn.Server(config)
    asyncio.run(server.serve())
</code></pre>
                </div>

                <div class="bg-white dark:bg-dark-card rounded-lg shadow-lg p-6">
                    <h3 class="text-xl font-bold mb-4">3. Scripts de Deploy e Monitoramento</h3>
                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto"><code class="language-bash">#!/bin/bash
# deploy.sh - Script de deploy automatizado

set -e

echo "üöÄ Iniciando deploy da aplica√ß√£o..."

# Vari√°veis
APP_NAME="realtime-app"
DOCKER_REGISTRY="seu-registry.com"
VERSION=$(git rev-parse --short HEAD)

# Build da imagem
echo "üì¶ Construindo imagem Docker..."
docker build -t $DOCKER_REGISTRY/$APP_NAME:$VERSION .
docker tag $DOCKER_REGISTRY/$APP_NAME:$VERSION $DOCKER_REGISTRY/$APP_NAME:latest

# Push para registry
echo "üì§ Enviando para registry..."
docker push $DOCKER_REGISTRY/$APP_NAME:$VERSION
docker push $DOCKER_REGISTRY/$APP_NAME:latest

# Deploy usando docker-compose
echo "üîÑ Fazendo deploy..."
export IMAGE_VERSION=$VERSION
docker-compose -f docker-compose.prod.yml down
docker-compose -f docker-compose.prod.yml up -d

# Aguarda aplica√ß√£o ficar saud√°vel
echo "üè• Verificando sa√∫de da aplica√ß√£o..."
for i in {1..30}; do
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        echo "‚úÖ Aplica√ß√£o est√° saud√°vel!"
        break
    fi
    echo "Aguardando... ($i/30)"
    sleep 10
done

# Testes de smoke
echo "üß™ Executando testes de smoke..."
curl -f http://localhost:8000/health
curl -f http://localhost:8000/metrics

echo "üéâ Deploy conclu√≠do com sucesso!"
</code></pre>

                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto mt-4"><code class="language-yaml"># prometheus.yml - Configura√ß√£o do Prometheus
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'realtime-app'
    static_configs:
      - targets: ['app:8000']
    metrics_path: '/metrics'
    scrape_interval: 5s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']

  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres:5432']

  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx:80']
</code></pre>

                    <pre class="bg-gray-800 text-green-400 p-4 rounded-lg overflow-x-auto mt-4"><code class="language-yaml"># kubernetes.yml - Deploy no Kubernetes
apiVersion: apps/v1
kind: Deployment
metadata:
  name: realtime-app
  labels:
    app: realtime-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: realtime-app
  template:
    metadata:
      labels:
        app: realtime-app
    spec:
      containers:
      - name: app
        image: seu-registry.com/realtime-app:latest
        ports:
        - containerPort: 8000
        env:
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: secret-key
        resources:
          limits:
            cpu: 500m
            memory: 512Mi
          requests:
            cpu: 200m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: realtime-app-service
spec:
  selector:
    app: realtime-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8000
  type: LoadBalancer

---
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: realtime-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: realtime-app
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
</code></pre>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer class="bg-gray-100 dark:bg-dark-card border-t border-gray-200 dark:border-gray-700 py-8">
            <div class="container mx-auto px-4 text-center">
                <p class="text-gray-600 dark:text-gray-400">
                    <i class="fas fa-code mr-2"></i>
                    Apostila criada para estudo de servi√ßos em tempo real com Python
                </p>
                <p class="text-sm text-gray-500 dark:text-gray-500 mt-2">
                    WebSocket ‚Ä¢ Socket.IO ‚Ä¢ Redis ‚Ä¢ Docker ‚Ä¢ Kubernetes
                </p>
            </div>
        </footer>
    </div>

    <script>
        // Dark mode detection
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Navigation
        function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.add('hidden');
            });
            
            // Show selected section
            document.getElementById(sectionId).classList.remove('hidden');
            
            // Update navigation buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.className = 'nav-btn px-4 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600';
            });
            
            event.target.className = 'nav-btn px-4 py-2 rounded-lg bg-primary text-white';
        }

        // Demo Chat Functions
        function sendDemoMessage() {
            const input = document.getElementById('demo-message-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            addDemoMessage('Voc√™', message, 'sent');
            input.value = '';
            
            // Simulate response
            setTimeout(() => {
                const responses = [
                    'Interessante! Conte-me mais.',
                    'Entendi, obrigado por compartilhar.',
                    'Essa √© uma boa observa√ß√£o!',
                    'Vou considerar isso. Valeu!',
                    'Excelente ponto de vista!'
                ];
                const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                addDemoMessage('Bot', randomResponse, 'received');
            }, 1000 + Math.random() * 2000);
        }

        function addDemoMessage(username, message, type) {
            const chatMessages = document.getElementById('demo-chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `mb-3 ${type === 'sent' ? 'text-right' : 'text-left'}`;
            
            const timestamp = new Date().toLocaleTimeString();
            const bgColor = type === 'sent' ? 'bg-primary text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-900 dark:text-white';
            
            messageDiv.innerHTML = `
                <div class="inline-block max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${bgColor}">
                    <div class="font-semibold text-sm">${username}</div>
                    <div>${message}</div>
                    <div class="text-xs opacity-75 mt-1">${timestamp}</div>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function simulateUserJoin() {
            const users = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'];
            const randomUser = users[Math.floor(Math.random() * users.length)];
            addDemoMessage('Sistema', `${randomUser} entrou na sala`, 'system');
        }

        function simulateSystemMessage() {
            const messages = [
                'Servidor ser√° reiniciado em 5 minutos',
                'Nova funcionalidade dispon√≠vel!',
                'Backup autom√°tico conclu√≠do',
                'Usu√°rios online: 47'
            ];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            addDemoMessage('Sistema', randomMessage, 'system');
        }

        function simulatePrivateMessage() {
            const users = ['Ana', 'Carlos', 'Bruno', 'Fernanda'];
            const randomUser = users[Math.floor(Math.random() * users.length)];
            addDemoMessage(`${randomUser} (privado)`, 'Oi! Como voc√™ est√°?', 'private');
        }

        function clearDemoChat() {
            document.getElementById('demo-chat-messages').innerHTML = '';
        }

        // Dashboard Functions
        let dashboardInterval = null;
        let dashboardActive = false;

        function toggleDashboard() {
            const btnText = document.getElementById('dashboard-btn-text');
            
            if (dashboardActive) {
                clearInterval(dashboardInterval);
                dashboardActive = false;
                btnText.textContent = 'Iniciar Dashboard';
            } else {
                startDashboard();
                dashboardActive = true;
                btnText.textContent = 'Parar Dashboard';
            }
        }

        function startDashboard() {
            dashboardInterval = setInterval(updateDashboard, 2000);
        }

        function updateDashboard() {
            // Update metrics
            const usersOnline = Math.floor(Math.random() * 100) + 50;
            const messagesPerMin = Math.floor(Math.random() * 50) + 10;
            
            document.getElementById('metric-users').textContent = usersOnline;
            document.getElementById('metric-messages').textContent = messagesPerMin;
            
            // Add activity log
            const activities = [
                'Usu√°rio conectado: user123',
                'Nova mensagem na sala #geral',
                'Servidor: CPU 45%',
                'Cache Redis atualizado',
                'Backup autom√°tico iniciado'
            ];
            
            const randomActivity = activities[Math.floor(Math.random() * activities.length)];
            addActivityLog(randomActivity);
        }

        function addActivityLog(message) {
            const activityLog = document.getElementById('activity-log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = 'text-xs text-gray-600 dark:text-gray-400 mb-1';
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            activityLog.appendChild(logEntry);
            
            // Keep only last 10 entries
            while (activityLog.children.length > 10) {
                activityLog.removeChild(activityLog.firstChild);
            }
            
            activityLog.scrollTop = activityLog.scrollHeight;
        }

        // Notification Functions
        function sendNotification() {
            const type = document.getElementById('notification-type').value;
            const message = document.getElementById('notification-message').value.trim();
            
            if (!message) {
                alert('Digite uma mensagem para a notifica√ß√£o');
                return;
            }
            
            addNotification(type, message);
            document.getElementById('notification-message').value = '';
        }

        function addNotification(type, message) {
            const container = document.getElementById('notifications-container');
            
            // Remove placeholder if exists
            if (container.querySelector('.text-gray-500')) {
                container.innerHTML = '';
            }
            
            const notification = document.createElement('div');
            const typeColors = {
                info: 'bg-blue-100 dark:bg-blue-900 border-blue-400 text-blue-800 dark:text-blue-200',
                success: 'bg-green-100 dark:bg-green-900 border-green-400 text-green-800 dark:text-green-200',
                warning: 'bg-yellow-100 dark:bg-yellow-900 border-yellow-400 text-yellow-800 dark:text-yellow-200',
                error: 'bg-red-100 dark:bg-red-900 border-red-400 text-red-800 dark:text-red-200'
            };
            
            const typeIcons = {
                info: 'fas fa-info-circle',
                success: 'fas fa-check-circle',
                warning: 'fas fa-exclamation-triangle',
                error: 'fas fa-times-circle'
            };
            
            notification.className = `border-l-4 p-3 rounded ${typeColors[type]}`;
            notification.innerHTML = `
                <div class="flex justify-between items-start">
                    <div class="flex items-center">
                        <i class="${typeIcons[type]} mr-2"></i>
                        <span class="text-sm">${message}</span>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="text-gray-500 hover:text-gray-700">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="text-xs opacity-75 mt-1">
                    ${new Date().toLocaleTimeString()}
                </div>
            `;
            
            container.insertBefore(notification, container.firstChild);
            
            // Auto remove after 5 seconds for success notifications
            if (type === 'success') {
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 5000);
            }
        }

        function clearNotifications() {
            const container = document.getElementById('notifications-container');
            container.innerHTML = '<div class="text-gray-500 text-center py-4">Nenhuma notifica√ß√£o</div>';
        }

        // Initialize demo messages
        document.addEventListener('DOMContentLoaded', function() {
            addDemoMessage('Sistema', 'Bem-vindo ao chat demo!', 'system');
            addDemoMessage('Ana', 'Ol√° pessoal! Como est√£o?', 'received');
            addDemoMessage('Carlos', 'Tudo bem! Testando este chat incr√≠vel', 'received');
            
            // Initialize activity log
            document.getElementById('activity-log').innerHTML = '<div class="text-gray-500">Aguardando atividades...</div>';
        });

        // Enter key support for demo chat
        document.getElementById('demo-message-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendDemoMessage();
            }
        });

        // Enter key support for notifications
        document.getElementById('notification-message').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendNotification();
            }
        });
    </script>
</body>
</html>